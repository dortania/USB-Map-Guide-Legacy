{"./":{"url":"./","title":"USB Mapping","keywords":"","body":" Last modified: Fri May 08 2020 17:22:02 GMT+0000 (Coordinated Universal Time) Why should you USB map? So the process of USB mapping is defining your ports to macOS and telling it what kind they are, the reasons we want to do this are: macOS is very bad at guessing what kind of ports you have Some ports may run below their rated speed(3.1 ports running at 2.0) Some ports may outright not work Certain services like Handoff may not work correctly Sleep may break Broken Hot-Plug Even data corruption from XhciPortLimit So now that you know why you should USB map, we can now talk about technical info of USB mapping. This is a section you cannot skip, otherwise all info below will seem like a very broken Russian translation written by a very drunk slav. So with USB, we need to understand not all ports are the same and that some ports are actually hiding other ports within them! What I mean by this is the following: A USB 3.0 port is actually seen as 2 ports to macOS: a USB 2.0 and USB 3.0 This is also how USB can keep its backwards compatibility, as all USB 3.0 devices must support USB 2.0 Now lets look at a diagram of a USB port to better understand this: As you can see, the bottom 4 ports are dedicated to USB 2.0 and when the extra 5 ports above are recognized the device will switch to a USB 3.0 mode. Now with the basic understanding out of the way, we now have to talk about the dreadful 15 port limit. macOS and the 15 Port Limit Now let me take you back in time to the late 2015's and the release of OS X 10.11, El Capitan. This was an update that established much of what both blesses us and pains us in the community like System Integrity Protection and the 15 port limit. What the 15 port limit is in macOS(then called OS X) is a strict limit of only 15 possible ports per controller, this becomes an issue when we look at the chipset ports included on your motherboard: Z170 and newer Chipsets: 26 Ports in total And you may not even have 26 actual ports, but they're still declared in your ACPI tables causing issues as macOS can't tell the difference between a real port and one your firmware writers forgot to remove. But why did Apple choose 15 ports as the limit? Well this gets into a fun subset of computers, the hexadecimal counting system! How this differs from our decimal system is that there are a total of 15 values with the last one being 0xF. This meant it was just cleaner to stop at 15 than to say expand the port limit to 255(0xFF), and in Apple's eyes it made little sense to have anything above 15 ports as no Macs they supported went over this limit. And if a Mac Pro user added a USB expansion card, it would get it's own 15 port limit. And now when we take into account the quirk XhciPortLimit, you can see why data corruption can happen. As we're pushing past the 0xF limit and going into someone else's space. So avoid this quirk when possible. What about USB hubs? USB Hubs attached to one of your USB controller's ports have a different kind of port limit. In total, a single USB port can be split into 127 ports. This includes USB hubs attached to USB hubs Now with the backstory done, lets head to System Preparations "},"system-preparation.html":{"url":"system-preparation.html","title":"System Preparation","keywords":"","body":" Last modified: Fri May 08 2020 17:22:03 GMT+0000 (Coordinated Universal Time) System Preparation So before we can USB map, we need to set a couple things: USBInjectAll under both EFI/OC/Kexts and config.plist -> Kernel -> Add We need this kext to make sure any ports not defined in ACPI will still show up in macOS, note that this shouldn't be required on Skylake and newer as the USB ports are defined within ACPI Note that this does not work on AMD config.plist -> Kernel -> Quirks -> XhciPortLimit -> True So we can temporally get around the 15 port limit to map our ports config.plist -> ACPI -> Patch -> EHCI and XHCI ACPI renames The reason we need these ACPI renames are due to conflicting with Apple's own USB map, fun fact even Apple has to USB map as well! You can actually find Apple's USB map within IOUSBHostFamily.kext -> PlugIns -> AppleUSBHostPlatformProperties.kext in Catalina, though newer Macs actually port map with their ACPI tables instead. SMBIOSes that do not need the ACPI renames: iMac18,x and newer MacPro7,1 and newer Macmini8,1 and newer MacBook9,x and newer MacBookAir8,x and newer MacBookPro13,x and newer And so with older SMBIOSes(one's not listed above), we need to make sure their port map does not attach while we're trying to USB map ourselves. Else some ports may disappear, and please check you do have these ports in your ACPI tables before applying these patches as we don't want to patch the wrong devices. If you do find your USB controller needs renaming, write down their original names before the rename as this will make USB mapping down the road a bit easier: XHC1 to SHCI: Needed for Skylake and older SMBIOS Key Type Value Comment String XHC1 to SHCI Count Number Enabled Boolean YES Find Data Limit Number Replace Data Skip Number Tablelength Number TableSignature Data <> EHC1 to EH01: Needed for Broadwell and older SMBIOS Key Type Value Comment String EHC1 to EH01 Count Number Enabled Boolean YES Find Data Limit Number Replace Data Skip Number Tablelength Number TableSignature Data <> EHC2 to EH02: Needed for Broadwell and older SMBIOS Key Type Value Comment String EHC2 to EH02 Count Number Enabled Boolean YES Find Data Limit Number Replace Data Skip Number Tablelength Number TableSignature Data <> And for those worried about ACPI patches applying to other OSes, these will only be temporary and will be removed once we've mapped our ports. Checking what renames you need So with renames it's pretty easy to find out, first figure out what SMBIOS you're using(can be found in your config.plist under PlatformInfo -> Generic -> SystemProductName) and match figure out whether you even need a USB map: SMBIOS needing only XHC1 rename: iMacPro1,1 iMac17,x and older MacBookAir7,x SMBIOS needing XHC1 and EHC1 rename: MacPro6,1 Macmini7,1 MacBook8,x MacBookAir6,x MacBookPro12,x SMBIOS needing XHC1, EHC1 and EHC2 renames: iMac16,x and older MacPro5,1 and older Macmini6,x and older MacBookAir5,x and older MacBookPro11,x and older Now that we know what renames our SMBIOS need, we can next check the names of our USB controllers. Run the following in terminal: ioreg -l -p IOService -w0 | grep -i EH01 ioreg -l -p IOService -w0 | grep -i EH02 ioreg -l -p IOService -w0 | grep -i XHC1 We recommend running 1 at a time as terminal may get flooded if you tried to search for all 3 at the same time, the below example shows we don't have anything named EH01 or EH02 but we do however require that XHC1 rename: And with that, we now add our needed ACPI renames to our config.plist -> ACPI -> Patch, you can find a pre-made file here(note that you'll need to enable the ones you need): usb-rename.plist Parting ways But now we must part into 2 sections, depending on which hardware you have: Intel USB Mapping AMD and 3rd Party USB Mapping "},"intel-mapping/intel.html":{"url":"intel-mapping/intel.html","title":"Intel USB Mapping","keywords":"","body":" Last modified: Fri May 08 2020 17:22:03 GMT+0000 (Coordinated Universal Time) USB Mapping Table of Contents: Intel USB Mapping Removing ACPI Renames So with the prerequisites out of the way, we can finally get to the meat of this guide. And now we get to finally read one of my favorite books before I go to bed each night: The Advanced Configuration and Power Interface (ACPI) Specification! Now if you haven't read through this before(which I highly recommend you do, it's a thrilling tale), I'll point you to the meat of the USB situation: Section 9.14: _UPC (USB Port Capabilities) Here we're greeted with all the possible USB ports in ACPI: Type Info Comments 0 USB 2.0 Type-A connector This is what macOS will default all ports to when no map is present 3 USB 3.0 Type-A connector 3.0, 3.1 and 3.2 ports share the same Type 8 Type C connector - USB 2.0-only Mainly seen in phones 9 Type C connector - USB 2.0 and USB 3.0 with Switch Flipping the device does not change the ACPI port 10 Type C connector - USB 2.0 and USB 3.0 without Switch Flipping the device does change the ACPI port. generally seen on 3.1/2 motherboard headers 255 Proprietary connector For Internal USB ports like Bluetooth Intel USB Mapping USB mapping on Intel is super easy mainly because both the ACPI is sane and more tools available for the platform. For this guide well be using the USBmap tool from CorpNewt. Now open up USBmap.command and select D. Discover Ports: The interface for USBmap is quite simple and easy to grasp so won't go into detail here, the README.md should do you well enough. The basic idea is insert a device, give it a name to remember the port by, remove and then try another port unti you have a whole list of ports you want to keep. Once you're done discovering your ports, select Press Q then [enter] to stop then head to P. Edit Plist & Create SSDT/Kext from the main menu. For this example, I'll choose all the ports that were discovered, remember that there is a 15 port limit so you cannot go over it. USB hubs will count as one USB port so you can expand from there is you are limited on ports. T:1,3,4,5,6,716,17,19,21,22:3 The above will set all ports listed to type 3 which is USB 3.0. T:9:255 This will set my Bluetooth to internal, this is super important as macOS expects Bluetooth to always be internal. Now we can select K. Build USBMap.kext and let it build our kext for us. Note: Do note use either the SSDT-UIAC.aml or USBInjectAll with the USBmap.kext. This kext we just made should be used by itself with no other USB kexts besides XhciUnsupported if your system needs it. Reason for this is USBInjectAll is no longer being maintained(rest in peace Rehabman) and the USBmap.kext version is how real Macs USB map as well so as close to \"Apple Like\" as possible to fit the OpenCore mood. Now reboot and run USBmap again, you should see a lot less ports in your map: Removing ACPI Renames Now once you've mapped your USB ports, we can finally remove those pesky ACPI renames. USBmap.command will have made the kext with the renamed controllers so we're going to have to change them back to the proper names to avoid any headaches when booting Windows or Linux. To start, right click the kext and select Show Package Contents, then head to Contents -> Info.plist And you'll want to rename the IONameMatch value to your unpatched controller's name: SHCI -> XHC1 EH01 -> EHC1 EH02 -> EHC2 And once that's done, you'll next want to head to your config.plist and disable the ACPI patches ACPI -> Patch -> Enabled -> False "},"amd-mapping/amd.html":{"url":"amd-mapping/amd.html","title":"AMD and 3rd Party USB Mapping","keywords":"","body":" Last modified: Fri May 08 2020 17:22:02 GMT+0000 (Coordinated Universal Time) USB Mapping Table of Contents: AMD and 3rd Party USB Mapping Creating the map Port mapping on screwed up DSDTs Port mapping when you have multiple of the same controller So with the prerequisites out of the way, we can finally get to the meat of this guide. And now we get to finally read one of my favorite books before I go to bed each night: The Advanced Configuration and Power Interface (ACPI) Specification! Now if you haven't read through this before(which I highly recommend you do, it's a thrilling tale), I'll point you to the meat of the USB situation: Section 9.14: _UPC (USB Port Capabilities) Here we're greeted with all the possible USB ports in ACPI: Type Info Comments 0 USB 2.0 Type-A connector This is what macOS will default all ports to when no map is present 3 USB 3.0 Type-A connector 3.0, 3.1 and 3.2 ports share the same Type 8 Type C connector - USB 2.0-only Mainly seen in phones 9 Type C connector - USB 2.0 and USB 3.0 with Switch Flipping the device does not change the ACPI port 10 Type C connector - USB 2.0 and USB 3.0 without Switch Flipping the device does change the ACPI port. generally seen on 3.1/2 motherboard headers 255 Proprietary connector For Internal USB ports like Bluetooth AMD and 3rd Party USB Mapping The steps are quite simple: Read this guide Cry a bit Cry some more Buy some Intel hardware Return said hardware Gather courage to USB map on AMD Read the rest of the guide again and actually USB map Creating the map So to start off, open IORegistryExplorer and find the USB controller you'd wish to map. For controllers, they come in some variations: XHC XHC0 XHC1 XHC2 XHCI XHCX AS43 PTXH (Commonly associated with AMD Chipset controllers) PXSX(This is a generic PCIe device, double check it's a USB device) The best way to find controllers is by searching for XHC and then looking at the results that come up, the parent of all the ports is the USB controller. Do note that many boards have multiple controllers but the port limit is per controller. For today's example, we'll be both adding missing ports and getting under the 15 port limit for this X399 chipset which has the identifier PTXH As you can see from the photo above, we're missing a shit ton of ports! Specifically ports POT3, POT4, POT7, POT8, PO12, PO13, PO15, PO16, PO17, PO18, PO19, PO20, PO21, PO22! So how do we fix this? Well if you look in the corner you'll see the port value. This is going to be important to us when mapping Next, let's take a peek at our DSDT and check for our PTXH device with maciASL: Top of PTXH Bottom of PTXH All of our ports are here! So why in the world is macOS hiding them? Well there's a couple of reasons but this being the main: Conflicting SMBIOS USB map Inside the AppleUSBHostPlatformProperties.kext you'll find the USB map for most SMBIOS, this means that that machine's USB map is forced onto your system. Well to kick out these bad maps, we gotta make a plugin kext. For us, that's the AMD-USB-Map.kext Now right-click and press Show Package Contents, then navigate to Contents/Info.plist If the port values don't show in Xcode, right click and select Show Raw Keys/Values So what kind of data do we shove into this plist? Well, there are a couple of sections to note: Model: SMBIOS the kext will match against, set this up to what SMBIOS you are currently using IONameMatch: The name of the controller it'll match against, in this example we'll use PTXH port-count: The last/largest port value that you want to be injected port: The address of the USB controller UsbConnector: The type of USB connector, which can be found on the ACPI 6.3 spec, section 9.14 How do I know which ports are 2.0 and which are 3.0? Well, the easiest way is grabbing a USB 2.0 and USB 3.0 device, then write down which ports are are what type from observing IOReg. Now, let's take this section: Device (PO18) { Name (_ADR, 0x12) // _ADR: Address Name (_UPC, Package (0x04) // _UPC: USB Port Capabilities { Zero, 0xFF, Zero, Zero }) } For us, what matters is the Name (_ADR, 0x12) // _ADR: Address as this tells us the location of the USB port. This value will be turned into our port value on the plist. Some DSDTs don't declare their USB address, for these situations we can see their IOReg properties. Reminder: Don't drag and drop the kext, read the guide carefully. Rename IONameMatch value to the correct controller you're wanting to map and verify that the ports are named correctly to your DSDT. If you could drag and drop it and have it work for everyone there wouldn't be a guide ;p Now save and add this to both your kext folder and config.plist then reboot! Now we can finally start to slowly remove unwanted ports from the Info.plist and remove the XhciPortLimit quirk once you have 15 ports total or less per controller. Port mapping on screwed up DSDTs Something you may have noticed is that your DSDT is even missing some ports, like for example: In this DSDT, we're missing HS02, HS03, HS04, HS05, etc. When this happens, we actually need to outright remove all our ports from that controller in our DSDT. What this will let us do is allow macOS to build the ports itself instead of basing it off of the ACPI. Save this modified DSDT.aml and place it in your EFI/OC/ACPI folder and specify it in your config.plist -> ACPI -> Add(note that DSDT.aml must be forced to work correctly) Port mapping when you have multiple of the same controller This becomes a problem when we run systems with many USB controllers which all want to have the same identifier, commonly being multiple XHC0 devices or AsMedia controllers showing up as generic PXSX devices. To fix this, we have 2 options: ACPI Rename (won't be covered in this guide, see ACPI section of OpenCore's configuration.pdf) SSDT Recreation SSDT Recreation With the SSDT Recreation method, what we'll be doing is \"renaming\" the device but in reality creating a brand new device just for macOS that is in the exact same spot as your old USB controller. To do this, grab the following SSDT: SSDT-SHC0.dsl What you'll want to do is find a controller you want to rename, find its full ACPI path and replace the one in the sample SSDT. In our sample, we're be renaming PCI0.GP13.XHC0 to SHC0 so change accordingly. Note: In rare cases, macOS isn't able to properly rebuild the USB ports with the new \"fake\" USB controller. In these situations we need to manually add ports to it that are present in the original controller(ie. HS01, HS02, POT1, etc) But how do I map a non-standard controller that shows up as PXSX? Similar idea to regular SSDT renaming except you need to actually find the controller. This becomes difficult as SSDs, network controllers, and other generic PCIe devices can also show up as PXSX. Check the ACPI-path in IOreg to find its path: As we can see, IOACPIPlane:/_SB/PC00@0/RP05@1c0004/PXSX@0 would be interpreted as SB.PC00.RP05.PXSX And so from the above SSDT, we change the following: External (_SB_.PCI0.GP13, DeviceObj) -> External (_SB_.PC00.RP05, DeviceObj) External (_SB_.PCI0.GP13.XHC0, DeviceObj) -> External (_SB_.PC00.RP05.PXSX, DeviceObj) Scope (\\_SB.PCI0.GP13) -> Scope (\\_SB.PC00.RP05) Scope (XHC0) -> Scope (PXSX) "},"misc/":{"url":"misc/","title":"Miscellaneous Fixes","keywords":"","body":" Last modified: Fri May 08 2020 17:22:03 GMT+0000 (Coordinated Universal Time) Miscellaneous Fixes Fixing USB Power Fixing Shutdown/Restart GPRW/UPRW/LANC Instant Wake Patch Keyboard Wake Issues "},"misc/power.html":{"url":"misc/power.html","title":"Fixing USB Power","keywords":"","body":" Last modified: Fri May 08 2020 17:22:03 GMT+0000 (Coordinated Universal Time) Fixing USB Power With Skylake and newer SMBIOS, Apple no longer provides USB power settings via IOUSBHostFamily, this means we need to adopt the same method real Macs do and supply macOS with a USBX device. This will set both the wake and sleep power values for all your USB ports, and can help fix many high power devices: Mics DACs Webcams Bluetooth Dongles The following SMBIOS need USBX: iMac17,x and newer MacPro7,1 and newer iMacPro1,1 and newer Macmini8,1 and newer MacBook9,x and newer MacBookAir8,x and newer MacBookPro13,x and newer Luckily you can use a precompiled file for USBX: SSDT-USBX "},"misc/shutdown.html":{"url":"misc/shutdown.html","title":"Fixing Shutdown/Restart","keywords":"","body":" Last modified: Fri May 08 2020 17:22:03 GMT+0000 (Coordinated Universal Time) Fixing Shutdown/Restart So an odd quirk you may run into with macOS is that when you shutdown, your PC may instead restart itself. This is actually due to a missing S5 call that powers down the controller. Of course Windows and Linux implement hacks to get around this but macOS has no such fixes, instead we need to do the dirty work and fix their ACPI writing. Don't worry, this won't harm other OSes. For this we need the following: FixShutdown-USB-SSDT.dsl _PTS to ZPTS Patch USB Controller's ACPI Path To find the USB Controller that needs fixing, search for _PRW in your DSDT and see what Device is mentioned within it, generally this will be something like SB.PCI0.XHC. With the ACPI path, edit FixShutdown-USB-SSDT.dsl and compile it to a .aml file(Assembled). MaciASL can help you with this "},"misc/instant-wake.html":{"url":"misc/instant-wake.html","title":"GPRW/UPRW/LANC Instant Wake Patch","keywords":"","body":" Last modified: Fri May 08 2020 17:22:03 GMT+0000 (Coordinated Universal Time) GPRW/UPRW/LANC Instant Wake Patch Similar idea to the \"Fixing Shutdown/Restart\" section, macOS will instant wake if either USB or power states change while sleeping. To fix this we need to reroute the GPRW/UPRW/LANC calls to a new SSDT, verify you have instant wake issues before trying the below. Do not use all these ACPI patches at once, look through your DSDT and see what you have: SSDT ACPI Patch Comments SSDT-GPRW GPRW to XPRW Patch Use this if you have Method (GPRW, 2 in your ACPI SSDT-UPRW UPRW to XPRW Patch Use this if you have Method (UPRW, 2 in your ACPI SSDT-LANC LANC to XPRW Patch Use this if you have Device (LANC) in your ACPI ACPI Patches and SSDTs courtesy of Rehabman, 1Revenger1 and Fewtarius "},"misc/keyboard.html":{"url":"misc/keyboard.html","title":"Keyboard Wake Issues","keywords":"","body":" Last modified: Fri May 08 2020 17:22:03 GMT+0000 (Coordinated Universal Time) Keyboard Wake Issues So an odd bug with Intel's 100 series chipsets and newer is that sometimes macOS requires a second keyboard press or some other wake event to power up the monitor as well, with some requiring a keypress+power button to wake. Well to fix this, we need to either: Disable Darkwake(not ideal, as background tasks will also turn on the display) Set acpi-wake-type to the USB Controller(Recommended) Create a fake ACPI Device You can find a great write up on the whole situation and the fixes here: USB Fix. It's an excellent read and highly recommend to truly understand what is exactly happening, and it's not like you've done enough reading already with this guide ;p Method 1 - Add Wake Type Property (Recommended) So the ideal method is to declare the XHCI Controller(This is our USB Controller) to be an ACPI wake device, as we don't have compatible ECs for macOS to handle proper wake calls. To start, we'll need to grab the PciRoot of our USB Controller(we'll use gfxutil, Generally the names would be XHC, XHC1 and XHCI) Now with the PciRoot, open your config.plist and add a new entry under DeviceProperties -> Add, and add your PciRoot. Then create a child with the following attributes: acpi-wake-type | Data | Method 2 - Create a fake ACPI Device This method creates a fake ACPI Device that will be associated with the GPE, then add the property of acpi-wake-type with USBWakeFixup.kext. It's actually quite easy to setup, you'll need the following: USBWakeFixup.kext Both under EFI/OC/Kexts and your config..plist SSDT-USBW.dsl To create the SSDT-USBW for your specific system, you're gonna need the ACPI path of your USB controller. If we look back above to the gfxutil example, we can see it also lists our ACPI path: /PC00@0/XHCI@14 -> \\_SB.PC00.XHCI Now we can shove that into our SSDT: Now with that done, you can compile and add it to your EFI and config.plist. See Getting Started With ACPI for more info on compiling SSDTs "}}